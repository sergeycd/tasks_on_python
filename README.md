# tasks_on_python
It is simple tasks for demonstration my skills in python


++++++++++++++++++++++++++++++++++++++++++++++++++


Это простые задачки для демонстрации моих навыков работы с python
Всего тут будет 3 задачи, ниже я приведу их условия

Задача №1
В доме есть пять свободных квартир с номерами от 1 до 5. Нужно заселить
 их жильцами. Списки упорядочены по номерам квартир жильцов.
Создай словарь, где ключ — номер квартиры, а значение — списки с
именами жильцов. Каждая пара жильцов — это отдельный список.

Задача №2
Есть много мнемонических правил, чтобы запомнить цвета радуги. Одно
из них звучит так: каждый охотник желает знать где сидит фазан.
Первая буква в каждом слове обозначает один из цветов радуги:
к — красный;
о — оранжевый;
ж — жёлтый;
з — зелёный;
г — голубой;
с — синий;
ф — фиолетовый.
Есть два списка.
Список со словами из мнемонической фразы. Слова идут по порядку:
 первая буква в слове соответствует цвету радуги в порядке, который
  записан выше. 
 mnemo = ['каждый', 'охотник', 'желает', 'знать', 'где', 'сидит', 'фазан']

Список с цветами радуги. Цвета записаны не порядку, перемешаны.
colors = [
  'оранжевый', 'голубой', 'фиолетовый', 'красный', 'желтый', 'синий', 'зеленый'
]
Твоя задача — наполнить словарь rainbow_dict парами ключ-значение. Ключ — слово из списка mnemo, а значение — соответствующий слову цвет из списка colors.
Выведи словарь. Должно получиться так:
{'каждый': 'красный', 'охотник': 'оранжевый', 'желает': 'желтый', 'знать': 'зеленый', 'где': 'голубой', 'сидит': 'синий', 'фазан': 'фиолетовый'}

Задача №3
Словарь movies состоит из пар Название фильма и его Оценка.
movies = {'Игры разума': 8.3, 'Зеленая миля': 9.1, 'Леон': 8.5, 'Эффект бабочки': 8.2, 'Матрица': 8.6, 'Криминальное чтиво': 8.7} 
Твоя задача — отфильтровать фильмы по оценке. Оставь только те, у которых она больше или равна 8.5. Отфильтрованные пары запиши в новый словарь filtered_movies и выведи его на экран.



Задание 4
Строка содержит пять временных значений. Они записаны через запятую:

'1h 45m,360s,25m,30m 120s,2h 60s'.

Напиши цикл, который посчитает общее количество минут.

Результат сохрани в переменную и выведи на экран.

Используй в решении методы split(), replace() и оператор in.

Обрати внимание: временное значение может состоять из одного, двух
или трёх единиц времени.

Значения расшифровываются так:

часы — любое положительное целое число и символ h;
минуты — любое положительное целое число и символ m;
секунды — положительное целое число кратное 60 и символ s.


# Задание 5
# Исправь класс Tester так, чтобы:
# при вызове метода work_hard у экземпляра класса tester_1 печаталось
# 'tester_1 Можно отдыхать';
# при вызове метода work_hard у экземпляра класса tester_2 печаталось
# 'tester_2 Что ж, ещё часок поработаю!'.
# Вызовы менять не нужно.

# изначальный шаблон:
# class Tester:
#
#     def __init__(name):
#         name = name
#         deadline = True
#
#     def work_hard(self, deadline=True):
#         if self.deadline:
#             print(self.name, 'Что ж, ещё часок поработаю!')
#         else:
#             print(self.name, 'Можно отдыхать')
#
# tester_1 = Tester(name='tester_1')
# tester_1.work_hard(deadline=False)  # 'tester_1 Можно отдыхать'
# tester_2 = Tester(name='tester_2')
# tester_2.work_hard(deadline=True)   # 'tester_2 Что ж, ещё часок поработаю!'



# Задание 6
# Над каждым файлом можно производить операции:
# запись — W
# чтение — R
# запуск — X
# Напиши функцию, которая обрабатывает действия с файлами.
# В словаре files ключ — это имя файла, а значение — список из операций, которые доступны для этого файла:
# files = {
#     'cool_movie.avi': ['X'],
#     'math_summary.docx': ['R', 'W'],
#     'war_and_peace.txt': ['R', 'W', 'X']
# }
# Обрати внимание: ключи 'cool_movie.avi', 'math_summary.docx' и 'war_and_peace.txt' даны для примера. Словарь files
# может содержать и другие файлы. Названия файлов могут быть случайными, но они всегда соответствуют записи '<имя_файла>.<формат>'.
# К каждому из файлов идут запросы в произвольном порядке. Запрос выглядит так: '<действие> <название файла>'.
# Например: 'write cool_movie.avi' или 'read war_and_peace.txt'.
# Например:
# 'write cool_movie.avi' выведет Access denied,
# 'execute cool_movie.avi' выведет ОК.
# Функция принимает на вход один запрос в виде строки — например, 'write cool_movie.avi' — и возвращает OK или Access denied.
# Вызывать функцию необязательно.


# Задание 7
# Есть два пустых списка: word_list и marks_list. Напиши функцию, которая принимает на вход строку и наполняет списки:
# word_list — словами из строки;
# marks_list — знаками препинания из строки.
# Строка всегда состоит из слов и знаков препинания ,, !, ., ?. Слова разделяются одиночным пробелом.
# Подряд идёт только один знак препинания.
# Каждое предложение начинается с заглавной буквы и заканчивается знаком препинания.
# Например, в функцию передали строку с цитатой из сериала Breaking Bad
# 'Мне не грозит опасность, Скайлер, я сам опасность! Кто-то откроет дверь и схватит пулю. Думаешь, им буду я? Нет. Это я' \
# ' постучу в дверь.'.
# Результат будет таким:
# word_list = ['Мне', 'не', 'грозит', 'опасность', 'Скайлер', 'я', 'сам', 'Кто-то', 'откроет', 'дверь', 'и', 'схватит',
#              'пулю', 'Думаешь', 'им', 'буду', 'Нет', 'Это', 'постучу', 'в']
# marks_list = [',', '!', '.', '?']
# Ты можешь тестировать функцию на любой другой строке. Но убедись, что она соответствует условиям.
# Требования к результату обработки:
# Значения в списках идут по порядку и не повторяются.
# Если в строке несколько одинаковых значений, функция добавляет в список только первое вхождение.
# Регистр символов важен. Одинаковые слова, которые начинаются с маленькой и заглавной букв, — это разные слова.
# Например, «Мне» и «мне».
# В решении используй метод split(). Импортировать и применять дополнительные библиотеки и функции не нужно.
# Задача решается без регулярных выражений.


# Задание 8
# Реализуй класс TestCase, в котором будут:
# Конструктор, внутри которого устанавливаются атрибуты:
# id тест-кейса — рандомное трёхзначное число;
# name название тест-кейса — передаётся при создании объекта TestCase;
# steps — словарь, куда будут добавляться шаги тест-кейса;
# result — ожидаемый результат тест-кейса.
# Метод set_step — добавляет в словарь steps шаг тест-кейса. Принимает два параметра:
# step_number и step_text. Ключ — это step_number (номер шага), а значение — step_text (текстовое описание шага).
# Метод delete_step — удаляет шаг из steps по переданному в метод ключу step_number.
# Метод get_steps — возвращает текущий список шагов.
# Метод set_result — устанавливает ожидаемый результат в атрибут result по переданному параметру result.
# Метод get_test_case — печатает текущее состояние тест-кейса.